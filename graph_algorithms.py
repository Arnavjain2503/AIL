# -*- coding: utf-8 -*-
"""graph_algorithms.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sQAtmvW3ykgvPMhZ0uEJqNLlX9LjyO3v
"""

import pandas as pd
import heapq
from collections import defaultdict, deque

# 1. Recursive DFS from CSV
def read_graph_from_csv(filepath):
    df = pd.read_csv(filepath)
    graph = defaultdict(list)
    for _, row in df.iterrows():
        graph[row[0]].append(row[1])
        graph[row[1]].append(row[0])
    return graph

def recursive_dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start, end=' ')
    for neighbor in graph[start]:
        if neighbor not in visited:
            recursive_dfs(graph, neighbor, visited)

# 2. Non-recursive DFS (user input)
def non_recursive_dfs(graph, start):
    visited = set()
    stack = [start]
    while stack:
        node = stack.pop()
        if node not in visited:
            print(node, end=' ')
            visited.add(node)
            stack.extend(reversed([v for v, _ in graph[node]]))

# 3. BFS (user input)
def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    while queue:
        node = queue.popleft()
        print(node, end=' ')
        for neighbor, _ in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

# 4-7. Best First Search
def best_first_search(graph, heuristics, start, goal):
    visited = set()
    heap = [(heuristics[start], start)]
    while heap:
        _, current = heapq.heappop(heap)
        if current in visited:
            continue
        print(current, end=' ')
        if current == goal:
            break
        visited.add(current)
        for neighbor, _ in graph[current]:
            if neighbor not in visited:
                heapq.heappush(heap, (heuristics[neighbor], neighbor))

# 8-11. A* Algorithm
def a_star_search(graph, heuristics, start, goal):
    open_set = [(heuristics[start], 0, start)]
    g_score = {start: 0}
    visited = set()

    while open_set:
        _, current_g, current = heapq.heappop(open_set)
        if current in visited:
            continue
        print(current, end=' ')
        if current == goal:
            break
        visited.add(current)

        for neighbor, cost in graph[current]:
            tentative_g = current_g + cost
            if neighbor not in g_score or tentative_g < g_score[neighbor]:
                g_score[neighbor] = tentative_g
                f_score = tentative_g + heuristics.get(neighbor, float('inf'))
                heapq.heappush(open_set, (f_score, tentative_g, neighbor))

# Helpers
def build_graph_user_input(directed=False, weighted=False):
    graph = defaultdict(list)
    n = int(input("Enter number of edges: "))
    for _ in range(n):
        parts = input("Enter edge (format: src dest [weight]): ").split()
        src, dest = parts[0], parts[1]
        weight = int(parts[2]) if weighted else 1
        graph[src].append((dest, weight))
        if not directed:
            graph[dest].append((src, weight))
    return graph

def get_heuristics_user():
    heuristics = {}
    n = int(input("Enter number of heuristic values: "))
    for _ in range(n):
        node, h = input("Node and heuristic: ").split()
        heuristics[node] = int(h)
    return heuristics

def get_heuristics_csv(filepath):
    df = pd.read_csv(filepath)
    return dict(zip(df['Node'], df['Heuristic']))

def main():
    print("Choose from [1-11]: ")
    choice = int(input())

    if choice == 1:
        path = input("Enter CSV path for graph: ")
        g = read_graph_from_csv(path)
        start = input("Start node: ")
        recursive_dfs(g, start)

    elif choice == 2:
        g = build_graph_user_input()
        start = input("Start node: ")
        non_recursive_dfs(g, start)

    elif choice == 3:
        g = build_graph_user_input()
        start = input("Start node: ")
        bfs(g, start)

    elif choice in [4, 5, 6, 7]:
        directed = choice in [4, 7]
        weighted = choice in [5, 7]
        g = build_graph_user_input(directed, weighted)
        heuristics = get_heuristics_user()
        start = input("Start node: ")
        goal = input("Goal node: ")
        best_first_search(g, heuristics, start, goal)

    elif choice in [8, 10]:
        graph_path = input("CSV path for graph (src,dest,cost): ")
        df = pd.read_csv(graph_path)
        g = defaultdict(list)
        for _, row in df.iterrows():
            g[row[0]].append((row[1], row[2]))
            if choice == 10:
                g[row[1]].append((row[0], row[2]))
        heuristics = get_heuristics_csv(input("CSV for heuristics: "))
        start, goal = input("Start: "), input("Goal: ")
        a_star_search(g, heuristics, start, goal)

    elif choice in [9, 11]:
        directed = choice == 9
        g = build_graph_user_input(directed, weighted=True)
        heuristics = get_heuristics_user()
        start = input("Start: ")
        goal = input("Goal: ")
        a_star_search(g, heuristics, start, goal)

if __name__ == "__main__":
    main()