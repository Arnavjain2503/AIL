# -*- coding: utf-8 -*-
"""graph_algorithms.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sQAtmvW3ykgvPMhZ0uEJqNLlX9LjyO3v
"""

import pandas as pd
import heapq
from collections import defaultdict, deque

# 1. Recursive DFS from CSV
def read_graph_from_csv(filepath):
    df = pd.read_csv(filepath)
    graph = defaultdict(list)
    for _, row in df.iterrows():
        graph[row[0]].append(row[1])
        graph[row[1]].append(row[0])
    return graph

def recursive_dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start, end=' ')
    for neighbor in graph[start]:
        if neighbor not in visited:
            recursive_dfs(graph, neighbor, visited)

# 2. Non-recursive DFS (user input)
def non_recursive_dfs(graph, start):
    visited = set()
    stack = [start]
    while stack:
        node = stack.pop()
        if node not in visited:
            print(node, end=' ')
            visited.add(node)
            stack.extend(reversed([v for v, _ in graph[node]]))

# 3. BFS (user input)
def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    while queue:
        node = queue.popleft()
        print(node, end=' ')
        for neighbor, _ in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

# 4-7. Best First Search
def best_first_search(graph, heuristics, start, goal):
    visited = set()
    heap = [(heuristics[start], start)]
    while heap:
        _, current = heapq.heappop(heap)
        if current in visited:
            continue
        print(current, end=' ')
        if current == goal:
            break
        visited.add(current)
        for neighbor, _ in graph[current]:
            if neighbor not in visited:
                heapq.heappush(heap, (heuristics[neighbor], neighbor))

# 8-11. A* Algorithm
def a_star_search(graph, heuristics, start, goal):
    open_set = [(heuristics[start], 0, start)]
    g_score = {start: 0}
    visited = set()

    while open_set:
        _, current_g, current = heapq.heappop(open_set)
        if current in visited:
            continue
        print(current, end=' ')
        if current == goal:
            break
        visited.add(current)

        for neighbor, cost in graph[current]:
            tentative_g = current_g + cost
            if neighbor not in g_score or tentative_g < g_score[neighbor]:
                g_score[neighbor] = tentative_g
                f_score = tentative_g + heuristics.get(neighbor, float('inf'))
                heapq.heappush(open_set, (f_score, tentative_g, neighbor))

# Helpers
def build_graph_user_input(directed=False, weighted=False):
    graph = defaultdict(list)
    n = int(input("Enter number of edges: "))
    for _ in range(n):
        parts = input("Enter edge (format: src dest [weight]): ").split()
        src, dest = parts[0], parts[1]
        weight = int(parts[2]) if weighted else 1
        graph[src].append((dest, weight))
        if not directed:
            graph[dest].append((src, weight))
    return graph

def get_heuristics_user():
    heuristics = {}
    n = int(input("Enter number of heuristic values: "))
    for _ in range(n):
        node, h = input("Node and heuristic: ").split()
        heuristics[node] = int(h)
    return heuristics

def get_heuristics_csv(filepath):
    df = pd.read_csv(filepath)
    return dict(zip(df['Node'], df['Heuristic']))

def main():
    print("Choose from [1-11]: ")
    choice = int(input())

    if choice == 1:
        path = input("Enter CSV path for graph: ")
        g = read_graph_from_csv(path)
        start = input("Start node: ")
        recursive_dfs(g, start)

    elif choice == 2:
        g = build_graph_user_input()
        start = input("Start node: ")
        non_recursive_dfs(g, start)

    elif choice == 3:
        g = build_graph_user_input()
        start = input("Start node: ")
        bfs(g, start)

    elif choice in [4, 5, 6, 7]:
        directed = choice in [4, 7]
        weighted = choice in [5, 7]
        g = build_graph_user_input(directed, weighted)
        heuristics = get_heuristics_user()
        start = input("Start node: ")
        goal = input("Goal node: ")
        best_first_search(g, heuristics, start, goal)

    elif choice in [8, 10]:
        graph_path = input("CSV path for graph (src,dest,cost): ")
        df = pd.read_csv(graph_path)
        g = defaultdict(list)
        for _, row in df.iterrows():
            g[row[0]].append((row[1], row[2]))
            if choice == 10:
                g[row[1]].append((row[0], row[2]))
        heuristics = get_heuristics_csv(input("CSV for heuristics: "))
        start, goal = input("Start: "), input("Goal: ")
        a_star_search(g, heuristics, start, goal)

    elif choice in [9, 11]:
        directed = choice == 9
        g = build_graph_user_input(directed, weighted=True)
        heuristics = get_heuristics_user()
        start = input("Start: ")
        goal = input("Goal: ")
        a_star_search(g, heuristics, start, goal)

if __name__ == "__main__":
    main()

# Task 1: Implement Recursive Depth First Search Algorithm. Read the undirected unweighted graph from a .csv file.
'''
1. Recursive DFS (Depth First Search)
Theory:
DFS is a graph traversal algorithm that starts at the root node (or an arbitrary node in the case of a disconnected graph) and explores as far as possible along each branch before backtracking.

It can be implemented using recursion (which internally uses the call stack) or iteration (using an explicit stack).

DFS is particularly useful for exploring all the nodes and edges in a graph, and it can be used for tasks like finding connected components, topological sorting, and solving puzzles.

Algorithm:
Mark the current node as visited.

Visit all unvisited neighbors of the current node.

Recursively call DFS on unvisited neighbors.

Backtrack when all neighbors are visited.

'''
import pandas as pd
from collections import defaultdict

# Function to read the graph from a CSV file
def read_graph_from_csv(filepath):
    df = pd.read_csv(filepath)
    graph = defaultdict(list)
    for _, row in df.iterrows():
        graph[row[0]].append(row[1])
        graph[row[1]].append(row[0])
    return graph

# Recursive DFS function
def recursive_dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start, end=' ')
    for neighbor in graph[start]:
        if neighbor not in visited:
            recursive_dfs(graph, neighbor, visited)

if __name__ == '__main__':
    graph = read_graph_from_csv('/content/graph_data.csv')
    start_node = input("Enter starting node: ")
    print("DFS Traversal (Recursive):")
    recursive_dfs(graph, start_node)

# Task 2: Implement Non-Recursive Depth First Search Algorithm. Read the undirected unweighted graph from user.
'''2. Non-Recursive DFS
Theory:
Non-recursive DFS is an iterative version of DFS. Instead of using the call stack, we explicitly use a stack data structure to manage the nodes that need to be explored.

This method avoids the risk of a stack overflow (which can occur in recursive DFS for deep graphs) and offers more control over the traversal process.

Algorithm:
Initialize a stack and add the starting node.

While the stack is not empty:

Pop a node from the stack.

If the node has not been visited, mark it as visited and print it.

Push all unvisited neighbors of the node onto the stack.

python
Copy
'''
from collections import defaultdict

# Function to read the graph from user input
def read_graph_from_user():
    graph = defaultdict(list)
    num_edges = int(input("Enter number of edges: "))
    for _ in range(num_edges):
        u, v = map(str, input("Enter an edge (u v): ").split())
        graph[u].append(v)
        graph[v].append(u)  # Since it's an undirected graph
    return graph

# Non-recursive DFS function
def non_recursive_dfs(graph, start):
    visited = set()
    stack = [start]
    print("DFS Traversal (Non-Recursive):")
    while stack:
        node = stack.pop()
        if node not in visited:
            print(node, end=' ')
            visited.add(node)
            stack.extend(reversed(graph[node]))  # Add neighbors to stack

if __name__ == '__main__':
    graph = read_graph_from_user()
    start_node = input("Enter starting node: ")
    non_recursive_dfs(graph, start_node)

# Task 3: Implement Breadth First Search Algorithm. Read the undirected unweighted graph from user.
'''3. BFS (Breadth-First Search)
Theory:
BFS is a graph traversal algorithm that explores all the nodes at the present depth level before moving on to nodes at the next depth level.

It uses a queue to keep track of the nodes to be explored. Nodes are added to the queue in the order they are discovered and removed in a FIFO (first-in-first-out) manner.

BFS is particularly useful for finding the shortest path in unweighted graphs and is commonly used in algorithms like Shortest Path and Web Crawlers.

Algorithm:
Initialize a queue and add the starting node to it.

While the queue is not empty:

Dequeue a node and print it.

Add all unvisited neighbors of the current node to the queue.

'''
from collections import deque, defaultdict

# Function to read the graph from user input
def read_graph_from_user():
    graph = defaultdict(list)
    num_edges = int(input("Enter number of edges: "))
    for _ in range(num_edges):
        u, v = map(str, input("Enter an edge (u v): ").split())
        graph[u].append(v)
        graph[v].append(u)  # Since it's an undirected graph
    return graph

# BFS function
def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    print("BFS Traversal:")
    while queue:
        node = queue.popleft()
        print(node, end=' ')
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

if __name__ == '__main__':
    graph = read_graph_from_user()
    start_node = input("Enter starting node: ")
    bfs(graph, start_node)

# Task 4: Implement Best First Search Algorithm. Read the directed unweighted graph and the heuristic values from user.
'''4. Best First Search
Theory:
Best First Search is an informed search algorithm that uses a heuristic to decide which node to explore next. The heuristic guides the search by estimating the cost from the current node to the goal.

It is often used when you have a good heuristic function to guide the search. In Best First Search, nodes with the best (smallest) heuristic values are explored first.

It is not guaranteed to find the shortest path but is useful when an effective heuristic is available.

Algorithm:
Initialize the open set (priority queue) with the start node.

While the open set is not empty:

Pop the node with the lowest heuristic value.

If the node is the goal, stop the search.

Otherwise, add its neighbors to the open set, prioritized by their heuristic values.

'''
from queue import PriorityQueue
from collections import defaultdict

# Function to read the graph and heuristics from user input
def read_graph_and_heuristics_from_user():
    graph = defaultdict(list)
    heuristics = {}

    num_nodes = int(input("Enter number of nodes: "))
    print("Enter node and heuristic value (node heuristic):")
    for _ in range(num_nodes):
        node, heuristic = input().split()
        heuristics[str(node)] = int(heuristic)

    num_edges = int(input("Enter number of edges: "))
    print("Enter edges (u v):")
    for _ in range(num_edges):
        u, v = input().split()
        graph[u].append(v)

    return graph, heuristics

# Best First Search function
def best_first_search(graph, heuristics, start, goal):
    pq = PriorityQueue()
    pq.put((heuristics[start], start))
    visited = set()
    path = []  # List to track the path of traversal

    print("Best First Search Traversal:")

    while not pq.empty():
        _, node = pq.get()
        path.append(node)  # Add the node to the path list

        if node == goal:
            print(" -> ".join(path))  # Print the path when the goal is reached
            return

        if node not in visited:
            visited.add(node)
            # Add all the neighbors to the priority queue, prioritized by their heuristic value
            for neighbor in graph[node]:
                pq.put((heuristics[neighbor], neighbor))

if __name__ == '__main__':
    graph, heuristics = read_graph_and_heuristics_from_user()

    # Input the starting and goal nodes
    start_node = input("Enter starting node: ")
    goal_node = input("Enter goal node: ")

    # Perform Best First Search and print the path
    best_first_search(graph, heuristics, start_node, goal_node)

# Task 5: Implement Best First Search Algorithm. Read the undirected weighted graph and the heuristic values from user.
from queue import PriorityQueue
from collections import defaultdict

# Function to read the graph and heuristics from user input
def read_graph_and_heuristics_from_user():
    graph = defaultdict(list)
    heuristics = {}

    num_nodes = int(input("Enter number of nodes: "))
    print("Enter node and heuristic value (node heuristic):")
    for _ in range(num_nodes):
        node, heuristic = input().split()
        heuristics[str(node)] = int(heuristic)

    num_edges = int(input("Enter number of edges: "))
    print("Enter edges (u v weight):")
    for _ in range(num_edges):
        u, v, weight = input().split()
        graph[u].append((v, int(weight)))
        graph[v].append((u, int(weight)))

    return graph, heuristics

# Best First Search function
def best_first_search(graph, heuristics, start, goal):
    pq = PriorityQueue()
    pq.put((heuristics[start], start))
    visited = set()
    path = []

    print("Best First Search Traversal:")

    while not pq.empty():
        _, node = pq.get()
        path.append(node)
        if node == goal:
            print(" -> ".join(path))
            return

        if node not in visited:
            visited.add(node)
            for neighbor, _ in graph[node]:
                pq.put((heuristics[neighbor], neighbor))

if __name__ == '__main__':
    graph, heuristics = read_graph_and_heuristics_from_user()

    start_node = input("Enter starting node: ")
    goal_node = input("Enter goal node: ")

    best_first_search(graph, heuristics, start_node, goal_node)

# Task 6: Implement Best First Search Algorithm. Read the undirected unweighted graph and the heuristic values from user.
from queue import PriorityQueue
from collections import defaultdict

# Function to read the graph and heuristics from user input
def read_graph_and_heuristics_from_user():
    graph = defaultdict(list)
    heuristics = {}

    num_nodes = int(input("Enter number of nodes: "))
    print("Enter node and heuristic value (node heuristic):")
    for _ in range(num_nodes):
        node, heuristic = input().split()
        heuristics[str(node)] = int(heuristic)

    num_edges = int(input("Enter number of edges: "))
    print("Enter edges (u v):")
    for _ in range(num_edges):
        u, v = input().split()
        graph[u].append(v)
        graph[v].append(u)
    return graph, heuristics

# Best First Search function
def best_first_search(graph, heuristics, start, goal):
    pq = PriorityQueue()
    pq.put((heuristics[start], start))
    visited = set()
    path = []
    print("Best First Search Traversal:")

    while not pq.empty():
        _, node = pq.get()
        path.append(node)
        if node == goal:
            print(" -> ".join(path))
            return

        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                pq.put((heuristics[neighbor], neighbor))

if __name__ == '__main__':
    graph, heuristics = read_graph_and_heuristics_from_user()

    start_node = input("Enter starting node: ").strip()
    goal_node = input("Enter goal node: ").strip()
    best_first_search(graph, heuristics, start_node, goal_node)

# Task 7: Implement Best First Search Algorithm. Read the directed weighted graph and the heuristic values from user.
from queue import PriorityQueue
from collections import defaultdict

# Function to read the graph and heuristics from user input
def read_graph_and_heuristics_from_user():
    graph = defaultdict(list)
    heuristics = {}

    num_nodes = int(input("Enter number of nodes: "))
    print("Enter node and heuristic value (node heuristic):")
    for _ in range(num_nodes):
        node, heuristic = input().split()
        heuristics[str(node)] = int(heuristic)

    num_edges = int(input("Enter number of edges: "))
    print("Enter edges (u v weight):")
    for _ in range(num_edges):
        u, v, weight = input().split()
        graph[u].append((v, int(weight)))
    return graph, heuristics

# Best First Search function
def best_first_search(graph, heuristics, start, goal):
    pq = PriorityQueue()
    pq.put((heuristics[start], start))
    visited = set()
    path = []
    print("Best First Search Traversal:")

    while not pq.empty():
        _, node = pq.get()
        path.append(node)
        if node == goal:
            print(" -> ".join(path))
            return

        if node not in visited:
            visited.add(node)
            for neighbor, _ in graph[node]:
                pq.put((heuristics[neighbor], neighbor))

if __name__ == '__main__':
    graph, heuristics = read_graph_and_heuristics_from_user()

    start_node = input("Enter starting node: ").strip()
    goal_node = input("Enter goal node: ").strip()

    best_first_search(graph, heuristics, start_node, goal_node)

import heapq

def read_graph_from_user():
    graph = {}
    heuristic = {}

    num_nodes = int(input("Enter number of nodes: "))
    for _ in range(num_nodes):
        node = input("Enter node name: ").strip()
        h = int(input(f"Enter heuristic value for {node}: "))
        heuristic[node] = h
        graph.setdefault(node, [])

    num_edges = int(input("Enter number of edges: "))
    for _ in range(num_edges):
        src = input("Enter source node: ").strip()
        dest = input("Enter destination node: ").strip()

        graph.setdefault(src, []).append(dest)
        graph.setdefault(dest, [])

    return graph, heuristic

def best_first_search(graph, start, goal, heuristic):
    open_list = []
    heapq.heappush(open_list, (heuristic[start], [start]))

    while open_list:
        _, path = heapq.heappop(open_list)
        node = path[-1]

        if node == goal:
            return path

        for neighbor in graph.get(node, []):
            if neighbor not in path:
                heapq.heappush(open_list, (heuristic[neighbor], path + [neighbor]))
    return None

graph, heuristic = read_graph_from_user()
start = input("Enter the start node: ").strip()
goal = input("Enter the goal node: ").strip()

if start in graph and goal in graph:
      path = best_first_search(graph, start, goal, heuristic)
      if path:
          print("Path from {} to {}: {}".format(start, goal, ' -> '.join(path)))
      else:
          print("No path found from {} to {}.".format(start, goal))
else:
      print("Invalid start or goal node.")d

# Task 8: Implement A* algorithm. Read directed weighted graph and heuristic values from a .csv file.
'''Theory:
A* is an informed search algorithm that combines the features of Best First Search and Dijkstraâ€™s Algorithm. It not only considers the heuristic but also the cost to reach the node from the start (denoted as g).

The key idea of A* is to prioritize nodes based on the total estimated cost, which is the sum of the actual cost (g) and the heuristic estimate (h), i.e., f = g + h.

A* is guaranteed to find the optimal solution if the heuristic is admissible (it does not overestimate the actual cost).

Algorithm:
Initialize the open set with the start node, where the priority is f = g + h (with g being the cost to reach the node and h being the heuristic value).

While the open set is not empty:

Pop the node with the lowest f value.

If the node is the goal, stop the search and return the path.

Otherwise, for each neighbor of the node:

Calculate the tentative g score and update the f score.

Add the neighbor to the open set with its new priority.'''
import pandas as pd
from queue import PriorityQueue
from collections import defaultdict

# Function to read graph and heuristics from CSV
def read_graph_and_heuristics_from_csv(graph_filepath, heuristics_filepath):
    df_graph = pd.read_csv(graph_filepath)
    graph = defaultdict(list)
    for _, row in df_graph.iterrows():
        graph[str(row[0])].append((str(row[1]), int(row[2])))  # u, v, weight
        graph[str(row[1])].append((str(row[0]), int(row[2])))  # Since it's undirected

    df_heuristics = pd.read_csv(heuristics_filepath)
    heuristics = dict(zip(df_heuristics['Node'], df_heuristics['Heuristic']))

    return graph, heuristics

# A* algorithm function
def a_star(graph, heuristics, start, goal):
    pq = PriorityQueue()
    pq.put((heuristics[start], start))  # Use heuristic value to prioritize the nodes
    g_values = {start: 0}
    visited = set()
    parent = {start: None}  # Track the parent nodes for path reconstruction

    print("A* Traversal:")

    while not pq.empty():
        _, node = pq.get()
        print(f"Visiting node: {node}")
        if node == goal:
            print(f"Reached goal {goal}")
            break

        if node not in visited:
            visited.add(node)

            # Check all neighbors and update the A* values
            for neighbor, weight in graph[node]:
                tentative_g_value = g_values[node] + weight
                if neighbor not in g_values or tentative_g_value < g_values[neighbor]:
                    g_values[neighbor] = tentative_g_value
                    pq.put((g_values[neighbor] + heuristics[neighbor], neighbor))
                    parent[neighbor] = node  # Store the parent for path reconstruction

    # Reconstruct the path from the goal node to the start node
    path = []
    current_node = goal
    while current_node is not None:
        path.append(current_node)
        current_node = parent[current_node]

    print("Path from start to goal:", " -> ".join(path[::-1]))

if __name__ == '__main__':
    graph, heuristics = read_graph_and_heuristics_from_csv('graph_data.csv', 'heuristic_data.csv')  # Provide your CSV file paths
    start_node = input("Enter starting node: ")
    goal_node = input("Enter goal node: ")
    a_star(graph, heuristics, start_node, goal_node)

# Task 9: Implement A* algorithm. Read directed weighted graph and heuristic values from user.
from queue import PriorityQueue
from collections import defaultdict

# Function to read the graph and heuristics from user input
def read_graph_and_heuristics_from_user():
    graph = defaultdict(list)
    heuristics = {}

    num_nodes = int(input("Enter number of nodes: "))
    print("Enter node and heuristic value (node heuristic):")
    for _ in range(num_nodes):
        node, heuristic = input().split()
        heuristics[str(node)] = int(heuristic)
    num_edges = int(input("Enter number of edges: "))
    print("Enter edges (u v weight):")
    for _ in range(num_edges):
        u, v, weight = input().split()
        graph[u].append((v, int(weight)))
    return graph, heuristics

# A* algorithm function
def a_star(graph, heuristics, start, goal):
    pq = PriorityQueue()
    pq.put((heuristics[start], start))
    g_values = {start: 0}
    visited = set()
    parent = {start: None}

    print("A* Traversal:")

    while not pq.empty():
        _, node = pq.get()
        print(f"Visiting node: {node}")
        if node == goal:
            print(f"Reached goal {goal}")
            break

        if node not in visited:
            visited.add(node)

            for neighbor, weight in graph[node]:
                tentative_g_value = g_values[node] + weight
                if neighbor not in g_values or tentative_g_value < g_values[neighbor]:
                    g_values[neighbor] = tentative_g_value
                    pq.put((g_values[neighbor] + heuristics[neighbor], neighbor))
                    parent[neighbor] = node

    path = []
    current_node = goal
    while current_node is not None:
        path.append(current_node)
        current_node = parent[current_node]

    print("Path from start to goal:", " -> ".join(path[::-1]))
    2
if __name__ == '__main__':
    graph, heuristics = read_graph_and_heuristics_from_user()
    start_node = input("Enter starting node: ")
    goal_node = input("Enter goal node: ")
    a_star(graph, heuristics, start_node, goal_node)

# Task 10: Implement A* algorithm. Read undirected weighted graph and heuristic values from a .csv file.
import pandas as pd
from queue import PriorityQueue
from collections import defaultdict

# Function to read graph and heuristics from CSV
def read_graph_and_heuristics_from_csv(graph_filepath, heuristics_filepath):

    df_graph = pd.read_csv(graph_filepath)
    graph = defaultdict(list)
    for _, row in df_graph.iterrows():
        graph[str(row[0])].append((str(row[1]), int(row[2])))
        graph[str(row[1])].append((str(row[0]), int(row[2])))

    df_heuristics = pd.read_csv(heuristics_filepath)
    heuristics = dict(zip(df_heuristics['Node'], df_heuristics['Heuristic']))

    return graph, heuristics

# A* algorithm function
def a_star(graph, heuristics, start, goal):
    pq = PriorityQueue()
    pq.put((heuristics[start], start))
    g_values = {start: 0}
    visited = set()
    parent = {start: None}

    print("A* Traversal:")

    while not pq.empty():
        _, node = pq.get()
        print(f"Visiting node: {node}")
        if node == goal:
            print(f"Reached goal {goal}")
            break

        if node not in visited:
            visited.add(node)

            for neighbor, weight in graph[node]:
                tentative_g_value = g_values[node] + weight
                if neighbor not in g_values or tentative_g_value < g_values[neighbor]:
                    g_values[neighbor] = tentative_g_value
                    pq.put((g_values[neighbor] + heuristics[neighbor], neighbor))
                    parent[neighbor] = node
    path = []
    current_node = goal
    while current_node is not None:
        path.append(current_node)
        current_node = parent[current_node]

    print("Path from start to goal:", " -> ".join(path[::-1]))

if __name__ == '__main__':
    graph, heuristics = read_graph_and_heuristics_from_csv('/content/graph_data.csv', '/content/heuristic_data.csv')
    start_node = input("Enter starting node: ")
    goal_node = input("Enter goal node: ")
    a_star(graph, heuristics, start_node, goal_node)

# Task 11: Implement A* algorithm. Read undirected weighted graph and heuristic values from user.
from collections import defaultdict
from queue import PriorityQueue

# Function to read the graph and heuristics from a single input block
def read_graph_and_heuristics_from_user():
    graph = defaultdict(list)
    heuristics = {}

    num_nodes = int(input("Enter number of nodes: "))
    print("Enter node and heuristic value (node heuristic):")
    for _ in range(num_nodes):
        node, heuristic = input().split()
        heuristics[str(node)] = int(heuristic)
    num_edges = int(input("Enter number of edges: "))
    print("Enter edges (u v weight):")
    for _ in range(num_edges):
        u, v, weight = input().split()
        graph[u].append((v, int(weight)))
        graph[v].append((u, int(weight)))
    return graph, heuristics

# A* algorithm function
def a_star(graph, heuristics, start, goal):
    pq = PriorityQueue()
    pq.put((heuristics[start], start))
    g_values = {start: 0}
    visited = set()
    parent = {start: None}
    print("A* Traversal:")

    while not pq.empty():
        _, node = pq.get()

        print(f"Visiting node: {node}")

        if node == goal:
            print(f"Reached goal {goal}")
            break

        if node not in visited:
            visited.add(node)

            for neighbor, weight in graph[node]:
                tentative_g_value = g_values[node] + weight
                if neighbor not in g_values or tentative_g_value < g_values[neighbor]:
                    g_values[neighbor] = tentative_g_value
                    pq.put((g_values[neighbor] + heuristics[neighbor], neighbor))
                    parent[neighbor] = node
    path = []
    current_node = goal
    while current_node is not None:
        path.append(current_node)
        current_node = parent[current_node]

    print("Path from start to goal:", " -> ".join(path[::-1]))
if __name__ == '__main__':
    graph, heuristics = read_graph_and_heuristics_from_user()

    start_node = input("Enter starting node: ")
    goal_node = input("Enter goal node: ")
    a_star(graph, heuristics, start_node, goal_node)
